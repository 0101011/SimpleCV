from SimpleCV.base import *
import scipy.signal as sps
import scipy.optimize as spo
import copy


class LineScan(list):
    """
    **SUMMARY**

    A line scan is a one dimensional signal pulled from the intensity
    of a series of a pixels in an image. LineScan allows you to do a series
    of operations just like on an image class object. You can also treat the
    line scan as a python list object. A linescan object is automatically
    generated by calling ImageClass.getLineScan on an image. You can also
    roll your own by declaring a LineScan object and passing the constructor
    a 1xN list of values.

    **EXAMPLE**

    >>>> import matplotlib.pyplot as plt
    >>>> img = Image('lenna')
    >>>> s = img.getLineScan(y=128)
    >>>> ss = s.smooth()
    >>>> plt.plot(s)
    >>>> plt.plot(ss)
    >>>> plt.show()
    """
    pointLoc = None
    image = None
    
    def __getitem__(self,key):
        """
        **SUMMARY**

        Returns a LineScan when sliced. Previously used to
        return list. Now it is possible to use LineScanm member
        functions on sub-lists

        """
        if type(key) is types.SliceType: #Or can use 'try:' for speed
            return LineScan(list.__getitem__(self, key))
        else:
            return list.__getitem__(self,key)
        
    def __getslice__(self, i, j):
        """
        Deprecated since python 2.0, now using __getitem__
        """
        return self.__getitem__(slice(i,j))


    def smooth(self,degree=3):
        """
        **SUMMARY**

        Perform a Gasusian simple smoothing operation on the signal. 
        
        **PARAMETERS**

        * *degree* - The degree of the fitting function. Higher degree means more smoothing.        
        
        **RETURNS**

        A smoothed LineScan object. 
       
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth(7))
        >>>> plt.show()

        **NOTES** 
        Cribbed from http://www.swharden.com/blog/2008-11-17-linear-data-smoothing-in-python/
        """
        window=degree*2-1  
        weight=np.array([1.0]*window)  
        weightGauss=[]  
        for i in range(window):  
            i=i-degree+1  
            frac=i/float(window)    
            gauss=1/(np.exp((4*(frac))**2))    
            weightGauss.append(gauss) 
        weight=np.array(weightGauss)*weight   
        smoothed=[0.0]*(len(self)-window)  
        for i in range(len(smoothed)):  
            smoothed[i]=sum(np.array(self[i:i+window])*weight)/sum(weight)
        # recenter the signal so it sits nicely on top of the old
        front = self[0:(degree-1)]
        front += smoothed
        front += self[-1*degree:]
        retVal = LineScan(front)
        retVal.image = self.image
        retVal.pointLoc = self.pointLoc
        return retVal

    def normalize(self):
        """
        **SUMMARY**
        
        Normalize the signal so the maximum value is scaled to one.
        
        **RETURNS**

        A normalized scanline object.
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.normalize())
        >>>> plt.show()

        """
        temp = np.array(self, dtype='float32')
        temp = temp / np.max(temp)
        retVal = LineScan(list(temp[:]))
        retVal.image = self.image
        retVal.pointLoc = self.pointLoc
        return retVal

    def scale(self,value_range=(0,1)):
        """
        **SUMMARY**
       
        Scale the signal so the maximum and minimum values are
        all scaled to the values in value_range. This is handy
        if you want to compare the shape of two signals that
        are scaled to different ranges.
        
        **PARAMETERS**

        * *value_range* - A tuple that provides the lower and upper bounds
                          for the output signal. 
         
        **RETURNS**

        A scaled LineScan object. 
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.scale(value_range(0,255)))
        >>>> plt.show()

        **SEE ALSO**

        """        
        temp = np.array(self, dtype='float32')
        vmax = np.max(temp)
        vmin = np.min(temp)
        a = np.min(value_range)
        b = np.max(value_range)
        temp = (((b-a)/(vmax-vmin))*(temp-vmin))+a
        retVal = LineScan(list(temp[:]))
        retVal.image = self.image
        retVal.pointLoc = self.pointLoc
        return retVal

    def minima(self):
        """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """        
        # all of these functions should return
        # value, index, pixel coordinate
        # [(index,value,(pix_x,pix_y))...]        
        minvalue = np.min(self)
        idxs = np.where(np.array(self)==minvalue)[0]
        minvalue = np.ones((1,len(idxs)))*minvalue # make zipable
        minvalue = minvalue[0]
        pts = np.array(self.pointLoc)
        pts = pts[idxs]
        pts = [(p[0],p[1]) for p in pts] # un numpy this shit
        return zip(idxs,minvalue,pts)
        
    def maxima(self):
        """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """
        # all of these functions should return
        # value, index, pixel coordinate
        # [(index,value,(pix_x,pix_y))...]        
        maxvalue = np.max(self)
        idxs = np.where(np.array(self)==maxvalue)[0]
        maxvalue = np.ones((1,len(idxs)))*maxvalue # make zipable
        maxvalue = maxvalue[0]
        pts = np.array(self.pointLoc)
        pts = pts[idxs]
        pts = [(p[0],p[1]) for p in pts] # un numpy this shit
        return zip(idxs,maxvalue,pts)
 
    def derivative(self):
        """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """
        temp = np.array(self,dtype='float32')
        d = [0]
        d += list(temp[1:]-temp[0:-1])
        retVal = LineScan(d)
        retVal.image = self.image
        retVal.pointLoc = self.pointLoc
        return retVal
    
    def localMaxima(self):
        """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """        
        temp = np.array(self)
        idx = np.r_[True, temp[1:] > temp[:-1]] & np.r_[temp[:-1] > temp[1:], True]
        idx = np.where(idx==True)[0]
        values = temp[idx]
        pts = np.array(self.pointLoc)
        pts = pts[idx]
        pts = [(p[0],p[1]) for p in pts] # un numpy this shit
        return zip(idx,values,pts)

        
    def localMinima(self):
                """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """
        temp = np.array(self)
        idx = np.r_[True, temp[1:] < temp[:-1]] & np.r_[temp[:-1] < temp[1:], True]
        idx = np.where(idx==True)[0]
        values = temp[idx]
        pts = np.array(self.pointLoc)
        pts = pts[idx]
        pts = [(p[0],p[1]) for p in pts] # un numpy this shit
        return zip(idx,values,pts)

    def resample(self,n=100):
        """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """
        signal = sps.resample(self,n)
        pts = np.array(self.pointLoc)
        # we assume the pixel points are linear
        # so we can totally do this better manually 
        x = linspace(pts[0,0],pts[-1,0],n)
        y = linspace(pts[0,1],pts[-1,1],n)
        pts = zip(x,y)
        retVal = LineScan(list(signal))
        retVal.image = self.image
        retVal.pointLoc = pts
        return retVal


    # this needs to be moved out to a cookbook or something
    #def linear(xdata,m,b):
    #    return m*xdata+b

    # need to add polyfit too
    #http://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html
    def fitToModel(self,f,p0=None):
                """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """
        yvals = np.array(self,dtype='float32')
        xvals = range(0,len(yvals),1)
        popt,pcov = spo.curve_fit(f,xvals,yvals,p0=p0)
        yvals = f(xvals,*popt)
        retVal = LineScan(list(yvals))
        retVal.image = self.image
        retVal.pointLoc = self.pointLoc
        return retVal


    def getModelParameters(self,f,p0=None):
                """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """
        yvals = np.array(self,dtype='float32')
        xvals = range(0,len(yvals),1)
        popt,pcov = spo.curve_fit(f,xvals,yvals,p0=p0)
        return popt

    def convolve(self,kernel):
        """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        """        
        k = len(kernel)
        if( k%2 == 0):
            kl = (k/2)-1
            kt = k/2
        else:
            kl = (k-1)/2
            kt = kl
        out = np.convolve(self,kernel)
        out = out[kt:-1*kl]
        retVal = LineScan(out)
        retVal.image = self.image
        retVal.pointLoc = self.pointLoc
        return retVal

    def fft(self):
                """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        >>>> import matplotlib.pyplot as plt
        >>>> img = Image('lenna')
        >>>> sl = img.getLineScan(y=128)
        >>>> plt.plot(sl)
        >>>> plt.plot(sl.smooth)
        >>>> plt.show()

        **SEE ALSO**

        return the fft and the frequency values

        # we may want a log plot 
        plt.plot(freq,fft.real,freq,fft.imag)
        """
        signal = np.array(self,dtype='float32')
        fft = np.fft.fft(signal)
        freq = np.fft.fftfreq(len(signal))
        return (fft,freq)
        
        
    def ifft(self,fft):
        """
        **SUMMARY**

        
        
        **PARAMETERS**

        
        
        **RETURNS**

        * *degree* -
        
        **EXAMPLE**

        SimpleCV:1> img = Image('lenna')
        SimpleCV:2> sl = img.getLineScan(pt1=(0,0),pt2=(300,200))
        SimpleCV:3> fft,frq = sl.fft()
        SimpleCV:4> fft[30:] = 0 # low pass
        SimpleCV:5> sl2 = sl.ifft(fft)
        SimpleCV:6> import matplotlib.pyplot as plt
        SimpleCV:7> plt.plot(sl)
        SimpleCV:8> plt.plot(sl2)
        """
        signal = np.fft.ifft(fft)
        retVal = LineScan(signal.real)
        retVal.image = self.image
        retVal.pointLoc = self.pointLoc
        return retVal